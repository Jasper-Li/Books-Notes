4. Data Types and Expressions
In this chapter, we take a look at the basic data types and describe some fundamental rules for forming arithmetic expressions in Objective-C.
Data Types and Constants
You have already encountered the Objective-C basic data type int. As you will recall, a variable declared to be of type int can be used to contain integral values only—that is, values that do not contain decimal digits.
The Objective-C programming language provides three other basic data types: float, double, and char. A variable declared to be of type float can be used for storing floating-point numbers (values containing decimal digits). The double type is the same as type float, typically with roughly twice the range. The char data type can be used to store a single character, such as the letter a, the digit character 6, or a semicolon (more on this later).
In Objective-C, any literal number, single character, or character string is known as a constant. For example, the number 58 represents a constant integer value. The string @"Programming in Objective-C is fun." is an example of a constant character string object. The expression @5 is an example of a constant number object, as you’ll learn in Chapter 15, “Numbers, Strings, and Collections.”
Type int
An integer constant consists of a sequence of one or more digits. A minus sign preceding the sequence indicates that the value is negative. The values 158, –10, and 0 are all valid examples of integer constants. No embedded spaces are permitted between the digits, and commas can’t be used. (So, the value 12,000 is not a valid integer constant and must be written as 12000.)
Every value, whether it’s a character, an integer, or a floating-point number, has a range of values associated with it. This range has to do with the amount of storage allocated to store a particular type of data. In general, that amount is not defined in the language; it typically depends on the computer you’re running on and is therefore called implementation or machine dependent. For example, an integer variable might take 32 bits on your computer, or perhaps it might be stored in 64. If 64 bits were used, much larger numbers can be stored inside integer variables than if 32 bits were used instead.
Type float
You can use a variable declared to be of type float to store values containing decimal digits. A floating-point constant is distinguished by the presence of a decimal point. The values 3., 125.8, and -.0001 are all valid examples of floating-point constants. To display a floating-point value, the NSLogconversion characters %f or %g can be used.
Floating-point constants can also be expressed in so-called scientific notation. The value 1.7e4 is a floating-point value expressed in this notation that represents the value 1.7 x 104.
As noted, the double type is the same as type float, only with roughly twice the range.
Type char
You can use a char variable to store a single character. A character constant is formed by enclosing the character within a pair of single quotation marks. So 'a', ';', and '0' are all valid examples of character constants. The first constant represents the letter a, the second is a semicolon, and the third is the character zero—which is not the same as the number zero. Do not confuse a character constant, which is a single character enclosed in single quotes, with a C-style character string, which is any number of characters enclosed in double quotes. As mentioned in the last chapter, a string of characters enclosed in a pair of double quotes that is preceded by an @ character is an NSString character string object.
The character constant '\n', the newline character, is a valid character constant even though it seems to contradict the rule cited previously. The reason for this is that the backslash character is recognized as a special character. In other words, the Objective-C compiler treats the character '\n' as a single character, even though it is actually formed by two characters. Other special characters are initiated with the backslash character. The format characters %c can be used in an NSLog call to display the value of a char variable.
Program 4.1 uses the basic Objective-C data types.
Program 4.1.
Click here to view code image

#import <Foundation/Foundation.h>

int main (int argc, char * argv[])
{
   @autoreleasepool {
      int    integerVar = 100;
      float  floatingVar = 331.79;
      double doubleVar = 8.44e+11;
      char   charVar = 'W';

      NSLog (@"integerVar = %i", integerVar);
      NSLog (@"floatingVar = %f", floatingVar);
      NSLog (@"doubleVar = %e", doubleVar);
      NSLog (@"doubleVar = %g", doubleVar);
      NSLog (@"charVar = %c", charVar);
    }
    return 0;
}

Program 4.1. Output

integerVar = 100
floatingVar = 331.790009
doubleVar = 8.440000e+11
doubleVar = 8.44e+11
charVar = W

In the second line of the program’s output, notice that the value of 331.79, which is assigned to floatingVar, is actually displayed as 331.790009. The reason for this inaccuracy is the particular way in which numbers are internally represented inside the computer. You have probably come across the same type of inaccuracy when dealing with numbers on your calculator. If you divide 1 by 3 on your calculator, you get the result .33333333, with perhaps some additional 3s tacked on at the end. The string of 3s is the calculator’s approximation to one third. Theoretically, there should be an infinite number of 3s. But the calculator can hold only so many digits, thus the inherent inaccuracy of the machine. The same type of inaccuracy applies here: Certain floating-point values cannot be exactly represented inside the computer’s memory.
Qualifiers: long, long long, short, unsigned, and signed
If the qualifier long is placed directly before the int declaration, the declared integer variable is of extended range on some computer systems. An example of a long int declaration might be this:
long int factorial;
This declares the variable factorial to be a long integer variable. As with floats and doubles, the particular range of a long variable depends on your particular computer system.
To display the value of a long int using NSLog, the letter l is used as a modifier before the integer format characters. This means that the format characters %li can be used to display the value of a long int in decimal format.
You can also have a long long int variable, or even a long double variable to hold a floating point number with greater range.
The qualifier short, when placed in front of the int declaration, tells the Objective-C compiler that the particular variable being declared is used to store fairly small integer values. The motivation for using short variables is primarily one of conserving memory space, which can be an issue when the program needs a lot of memory and the amount of available memory is limited.
The final qualifier that can be placed in front of an int variable is used when an integer variable will be used to store only positive numbers. The following declares to the compiler that the variable counter is used to contain only positive values:
unsigned int counter;
Restricting the use of an integer variable to the exclusive storage of positive integers extends the range of the integer variable.
Type id
The id data type is used to store an object of any type. In a sense, it is a generic object type. For example, this line declares graphicObject to be a variable of type id:
id   graphicObject;
Methods can be declared to return values of type id, like so:
-(id) newObject: (int) type;
This declares an instance method called newObject that takes a single integer argument called type and returns a value of type id.
The id data type is an important data type used often in this book. We mention it in passing here for the sake of completeness. The id type is the basis for very important features in Objective-C know as polymorphism and dynamic binding, which Chapter 9, “Polymorphism, Dynamic Typing, and Dynamic Binding,” discusses extensively.
Table 4.1 summarizes the basic data types and qualifiers.
Table 4.1. Basic Data Types


Note
In the table, a leading zero in front of an integer constant indicates the constant is in octal (base 8) notation, whereas a leading 0x(or 0X) indicates it is in hexadecimal (base 16) notation. A number written as 0x.1p3 represents a hexadecimal floating constant. Don’t worry about these formats; they’re just summarized in the table here for completeness. Further, suffixes such as f, l (L), u (U), and ll (LL) can also be used to explicitly express constants as floats, longs, unsigned, and long long, respectively.


Arithmetic Expressions
In Objective-C, just as in nearly all programming languages, the plus sign (+) is used to add two values, the minus sign (-) is used to subtract two values, the asterisk (*) is used to multiply two values, and the slash (/) is used to divide two values. These operators are known as binary arithmetic operators because they operate on two values or terms.
Operator Precedence
You have seen how a simple operation such as addition can be performed in Objective-C. The following program further illustrates the operations of subtraction, multiplication, and division. The last two operations performed in the program introduce the notion that one operator can have a higher priority, or precedence, over another operator. In fact, each operator in Objective-C has a precedence associated with it.
This precedence is used to determine how an expression that has more than one operator is evaluated: The operator with the higher precedence is evaluated first. Expressions containing operators of the same precedence are evaluated either from left to right or from right to left, depending on the operator. This is known as the associative property of an operator.
Program 4.2.
Click here to view code image

// Illustrate the use of various arithmetic operators

#import <Foundation/Foundation.h>

int main (int argc, char * argv[])
{
   @autoreleasepool {
      int   a = 100;
      int   b = 2;
      int   c = 25;
      int   d = 4;
      int   result;

      result = a - b;      // subtraction
      NSLog (@"a - b = %i", result);

      result = b * c;      // multiplication
      NSLog (@"b * c = %i", result);

      result = a / c;      // division
      NSLog (@"a / c = %i", result);

      result = a + b * c;  // precedence
      NSLog (@"a + b * c = %i", result);

      NSLog (@"a * b + c * d = %i", a * b + c * d);
   }
  return 0;
}

Program 4.2. Output

a - b = 98
b * c = 50
a / c = 4
a + b * c = 150
a * b + c * d = 300

After declaring the integer variables a, b, c, d, and result, the program assigns the result of subtracting b from a to result and then displays its value with an appropriate NSLog call.
The next statement has the effect of multiplying the value of b by the value of c and storing the product in result:
result = b * c;
The result of the multiplication is then displayed using a NSLog call that should be familiar to you by now.
The next program statement introduces the division operator, the slash. The NSLog statement displays the result of 4, obtained by dividing 100 by 25, immediately following the division of a by c.
Attempting to divide an integer by zero results in abnormal termination or an exception when the division is attempted. Even if the program does not terminate abnormally, the results obtained by such a division will be meaningless. In Chapter 6, “Making Decisions,” you will see how you can check for division by zero before the division operation is performed. If the divisor is determined to be zero, an appropriate action can be taken and the division operation can be averted.
This expression does not produce the result of 2550 (102 × 25); instead, the result displayed by the corresponding NSLog statement is shown as 150:
a + b * c
This is because Objective-C, like most other programming languages, has rules for the order of evaluating multiple operations or terms in an expression. Evaluation of an expression generally proceeds from left to right. However, the operations of multiplication and division are given precedence over the operations of addition and subtraction. Therefore, the system evaluates the expression
a + b * c
as follows:
a + (b * c)
(This is the same way this expression would be evaluated if you applied the basic rules of algebra.)
If you want to alter the order of evaluation of terms inside an expression, you can use parentheses. In fact, the expression listed previously is a perfectly valid Objective-C expression. Thus, the following statement could have been substituted in Program 4.2 to achieve identical results:
result = a + (b * c);
However, if this expression were used instead, the value assigned to result would be 2550:
result = (a + b) * c;
This is because the value of a (100) would be added to the value of b (2) before multiplication by the value of c (25) would take place. Parentheses can also be nested, in which case evaluation of the expression proceeds outward from the innermost set of parentheses. Just be sure to have as many closed parentheses as you have open ones.
Notice from the last statement in Program 4.2 that it is perfectly valid to give an expression as an argument to NSLog without having to first assign the result of the expression evaluation to a variable. The expression
a * b + c * d
is evaluated according to the rules stated previously as
(a * b) + (c * d)
or
(100 * 2) + (25 * 4)
The result of 300 is handed to the NSLog routine.
Integer Arithmetic and the Unary Minus Operator
Program 4.3 reinforces what we have just discussed and introduces the concept of integer arithmetic.
Program 4.3.
Click here to view code image

// More arithmetic expressions

#import <Foundation/Foundation.h>

int main (int argc, char * argv[])
{
   @autoreleasepool {
      int   a = 25;
      int   b = 2;
      float c = 25.0;
      float d = 2.0;

      NSLog (@"6 + a / 5 * b = %i", 6 + a / 5 * b);
      NSLog (@"a / b * b = %i", a / b * b);
      NSLog (@"c / d * d = %f", c / d * d);
      NSLog (@"-a = %i", -a);
   }
   return 0;
}

Program 4.3. Output

6 + a / 5 * b = 16
a / b * b = 24
c / d * d = 25.000000
-a = -25

We inserted extra blank spaces between int and the declaration of a, b, and result in the first three statements to align the declaration of each variable. This helps make the program more readable. You also might have noticed in each program presented thus far that a blank space was placed around each operator. This, too, is not required and is done solely for aesthetic reasons. In general, you can add extra blank spaces just about anywhere that a single blank space is allowed. A few extra presses of the spacebar will prove worthwhile if the resulting program is easier to read.
The expression in the first NSLog call of Program 4.3 reinforces the notion of operator precedence. Evaluation of this expression proceeds as follows:
1. Because division has higher precedence than addition, the value of a (25) is divided by 5 first. This gives the intermediate result of 5.
2. Because multiplication also has higher precedence than addition, the intermediate result of 5 is next multiplied by 2, the value of b, giving a new intermediate result of 10.
3. Finally, the addition of 6 and 10 is performed, giving a final result of 16.
The second NSLog statement introduces a new twist. You would expect that dividing a by b and then multiplying by b would return the value of a, which has been set to 25. But this does not seem to be the case, as shown by the output display of 24. Did the computer lose a bit somewhere along the way? Very unlikely. The fact of the matter is that this expression was evaluated using integer arithmetic.
If you glance back at the declarations for the variables a and b, you will recall that both were declared to be of type int. Whenever a term to be evaluated in an expression consists of two integers, the Objective-C system performs the operation using integer arithmetic. In such a case, all decimal portions of numbers are lost. Therefore, when the value of a is divided by the value of b, or 25 is divided by 2, you get an intermediate result of 12, andnot 12.5, as you might expect. Multiplying this intermediate result by 2 gives the final result of 24, thus explaining the “lost” digit.
As you can see from the next-to-last NSLog statement in Program 4.3, if you perform the same operation using floating-point values instead of integers, you obtain the expected result.
The decision of whether to use a float variable or an int variable should be made based on the variable’s intended use. If you don’t need any decimal places, use an integer variable. The resulting program will be more efficient; that is, it will execute more quickly on many computers. However, if you need the decimal place accuracy, the choice is clear. The only question you then must answer is whether to use a float or a double. The answer to this question depends on the desired accuracy of the numbers you are dealing with, as well as their magnitude.
In the last NSLog statement, the value of the variable a is negated by use of the unary minus operator. A unary operator is one that operates on a single value, as opposed to a binary operator, which operates on two values. The minus sign actually has a dual role: As a binary operator, it is used for subtracting two values; as a unary operator, it is used to negate a value.
The unary minus operator has higher precedence than all other arithmetic operators, except for the unary plus operator (+), which has the same precedence. So the following expression results in the multiplication of -a by b:
c = -a * b;
The Modulus Operator
The last arithmetic operator to be presented in this chapter is the modulus operator, which is symbolized by the percent sign (%). Try to determine how this operator works by analyzing the output from Program 4.4.
Program 4.4.
Click here to view code image

// The modulus operator

#import <Foundation/Foundation.h>

int main (int argc, char * argv[])
{
   @autoreleasepool {
      int a = 25, b = 5, c = 10, d = 7;

      NSLog (@"a %% b = %i", a % b);
      NSLog (@"a %% c = %i", a % c);
      NSLog (@"a %% d = %i", a % d);
      NSLog (@"a / d * d + a %% d = %i", a / d * d + a % d);
   }
   return 0;
}

Program 4.4. Output

a % b = 0
a % c = 5
a % d = 4
a / d * d + a % d = 25

Note the statement inside main that defines and initializes the variables a, b, c, and d in a single statement.
As you know, NSLog uses the character that immediately follows the percent sign to determine how to print its next argument. However, if it is another percent sign that follows, the NSLog routine takes this as an indication that you really intend to display a percent sign and inserts one at the appropriate place in the program’s output.
You are correct if you concluded that the function of the modulus operator % is to give the remainder of the first value divided by the second value. In the first example, the remainder, of 25 divided by 5 is 0. If you divide 25 by 10, you would have a remainder of 5, as verified by the second line of output. Dividing 25 by 7 gives a remainder of 4, as shown in the third output line.
Let’s now turn our attention to the last arithmetic expression evaluated in the last statement. You will recall that any operations between two integer values in Objective-C are performed with integer arithmetic. Therefore, any remainder resulting from the division of two integer values is simply discarded. Dividing 25 by 7, as indicated by the expression a / d, gives an intermediate result of 3. Multiplying this value by the value of d, which is 7, produces the intermediate result of 21. Finally, adding the remainder of dividing a by d, as indicated by the expression a % d, leads to the final result of25. It is no coincidence that this value is the same as the value of the variable a. In general, this expression always equals the value of a, assuming, of course, that a and b are both integer values:
a / b * b + a % b
In fact, the modulus operator % is defined to work only with integer values.
As far as precedence is concerned, the modulus operator has equal precedence to the multiplication and division operators. This implies, of course, that an expression such as
table + value % TABLE_SIZE
will be evaluated as
table + (value % TABLE_SIZE)
Integer and Floating-Point Conversions
To effectively develop Objective-C programs, you must understand the rules used for the implicit conversion of floating-point and integer values in Objective-C. Program 4.5 demonstrates some of the simple conversions between numeric data types.
Program 4.5.
Click here to view code image

// Basic conversions in Objective-C

#import <Foundation/Foundation.h>

int main (int argc, char * argv[])
{
   @autoreleasepool {
      float  f1 = 123.125, f2;
      int    i1, i2 = -150;

      i1 = f1;   // floating to integer conversion
      NSLog (@"%f assigned to an int produces %i", f1, i1);

      f1 = i2;   // integer to floating conversion
      NSLog (@"%i assigned to a float produces %f", i2, f1);

      f1 = i2 / 100;   // integer divided by integer
      NSLog (@"%i divided by 100 produces %f", i2, f1);

      f2 = i2 / 100.0;   // integer divided by a float
      NSLog (@"%i divided by 100.0 produces %f", i2, f2);

      f2 = (float) i2 / 100;   // type cast operator
      NSLog (@"(float) %i divided by 100 produces %f", i2, f2);
   }
   return 0;
}

Program 4.5. Output

Click here to view code image
123.125000 assigned to an int produces 123
-150 assigned to a float produces -150.000000
-150 divided by 100 produces -1.000000
-150 divided by 100.0 produces -1.500000
(float) -150 divided by 100 produces -1.500000

Whenever a floating-point value is assigned to an integer variable in Objective-C, the decimal portion of the number gets truncated. So, when the value of f1 is assigned to i1 in the previous program, the number 123.125 is truncated, which means that only its integer portion, or 123, is stored in i1. The first line of the program’s output verifies that this is the case.
Assigning an integer variable to a floating variable does not cause any change in the value of the number; the system simply converts the value and stores it in the floating variable. The second line of the program’s output verifies that the value of i2 (–150) was correctly converted and stored in thefloat variable f1.
The next two lines of the program’s output illustrate two points to remember when forming arithmetic expressions. The first has to do with integer arithmetic, which we have already discussed in this chapter. Whenever two operands in an expression are integers (and this applies to short, unsigned, and long integers as well), the operation is carried out under the rules of integer arithmetic. Therefore, any decimal portion resulting from a division operation is discarded, even if the result is assigned to a floating variable (as we did in the program). When the integer variable i2 is divided by the integer constant 100, the system performs the division as an integer division. The result of dividing –150 by 100, which is –1, is, therefore, the value that is stored in the float variable f1.
The next division performed in the previous program involves an integer variable and a floating-point constant. Any operation between two values in Objective-C is performed as a floating-point operation if either value is a floating-point variable or constant. Therefore, when the value of i2 is divided by 100.0, the system treats the division as a floating-point division and produces the result of –1.5, which is assigned to the float variable f1.
The Type Cast Operator
You’ve already seen how enclosing a type inside a set of parentheses is used to declare the return and argument types when declaring and defining methods. It serves a different purpose when used inside expressions.
The last division operation from Program 4.5 that reads as follows introduces the type cast operator:
f2 = (float) i2 / 100;   // type cast operator
The type cast operator has the effect of converting the value of the variable i2 to type float for purposes of evaluating the expression. In no way does this operator permanently affect the value of the variable i2; it is a unary operator that behaves like other unary operators. Just as the expression -a has no permanent effect on the value of a, neither does the expression (float) a.
The type cast operator has a higher precedence than all the arithmetic operators except the unary minus and unary plus. Of course, if necessary, you can always use parentheses in an expression to force the terms to be evaluated in any desired order.
As another example of the use of the type cast operator, the expression
(int) 29.55 + (int) 21.99
is evaluated in Objective-C as
29 + 21
because the effect of casting a floating value to an integer is one of truncating the floating-point value. The expression
(float) 6 / (float) 4
produces a result of 1.5, as does the following expression:
(float) 6 / 4
The type cast operator is often used to coerce an object that is a generic id type into an object of a particular class. For example, the following lines typecasts the value of the id variable myNumber to a Fraction object:
id   myNumber;
Fraction *myFraction;
  ...
myFraction = (Fraction *) myNumber;
The result of the casting is assigned to the Fraction variable myFraction.
Assignment Operators
The Objective-C language permits you to combine the arithmetic operators with the assignment operator using the following general format:
op=
In this format, op is any of the arithmetic operators, including +, -, *, /, or %. In addition, op can be any of the bit operators for shifting and masking, discussed later.
Consider this statement:
count += 10;
The effect of the “plus equals” operator += is to add the expression on the right side of the operator to the expression on the left side of the operator and to store the result back into the variable on the left side of the operator. So, the previous statement is equivalent to this statement:
count = count + 10;
The following expression uses the “minus equals” assignment operator to subtract 5 from the value of counter:
counter -= 5
It is equivalent to this expression:
counter = counter - 5
This is a slightly more involved expression:
a /= b + c
It divides a by whatever appears to the right of the equals sign (or by the sum of b and c) and stores the result in a. The addition is performed first because the addition operator has higher precedence than the assignment operator. In fact, all operators but the comma operator have higher precedence than the assignment operators, which all have the same precedence.
In this case, this expression is identical to the following:
a = a / (b + c)
The motivation for using assignment operators is threefold. First, the program statement becomes easier to write because what appears on the left side of the operator does not have to be repeated on the right side. Second, the resulting expression is usually easier to read. Third, the use of these operators can result in programs that execute more quickly because the compiler can sometimes generate less code to evaluate an expression.
A Calculator Class
It’s time now to define a new class. We’re going to make a Calculator class, which will be a simple four-function calculator you can use to add, multiply, subtract, and divide numbers. Similar to a regular calculator, this one must keep track of the running total, or what’s usually called the accumulator. So, methods must let you set the accumulator to a specific value, clear it (or set it to zero), and retrieve its value when you’re done.Program 4.6 includes the new class definition and a test program to try your calculator.
Program 4.6.
Click here to view code image

// Implement a Calculator class

#import <Foundation/Foundation.h>

@interface Calculator: NSObject

// accumulator methods
-(void)   setAccumulator: (double) value;
-(void)   clear;
-(double) accumulator;

// arithmetic methods
-(void) add: (double) value;
-(void) subtract: (double) value;
-(void) multiply: (double) value;
-(void) divide: (double) value;
@end

@implementation Calculator
{
    double accumulator;
}

-(void) setAccumulator: (double) value
{
    accumulator = value;
}

-(void) clear
{
    accumulator = 0;
}

-(double) accumulator
{
    return accumulator;
}

-(void) add: (double) value
{
    accumulator += value;
}

-(void) subtract: (double) value
{
    accumulator -= value;
}

-(void) multiply: (double) value
{
    accumulator *= value;
}

-(void) divide: (double) value
{
    accumulator /= value;
}
@end

int main (int argc, char * argv[])
{
   @autoreleasepool {
      Calculator *deskCalc  = [[Calculator alloc] init];

      [deskCalc setAccumulator: 100.0];
      [deskCalc add: 200.];
      [deskCalc divide: 15.0];
      [deskCalc subtract: 10.0];
      [deskCalc multiply: 5];
      NSLog (@"The result is %g", [deskCalc accumulator]);
   }
   return 0;
}

Program 4.6. Output

The result is 50

The method definitions themselves are quite straightforward. The Calculator class has only one instance variable, a double value that holds the value of the accumulator.
Notice the message that invokes the multiply method:
[deskCalc multiply: 5];
The argument to the method is an integer, yet the method expects a double. No problem arises here because numeric arguments to methods are automatically converted to match the type expected. A double is expected by multiply:, so the integer value 5 automatically is converted to a double precision floating value when the function is called. Even though this automatic conversion takes place, it’s better programming practice to supply the correct argument types when invoking methods.
Realize that unlike the Fraction class, in which you might work with many different fractions, you might want to work with only a single Calculatorobject in your program. Yet it still makes sense to define a new class to make working with this object easy. At some point, you might want to add a graphical front end to your calculator so that the user can actually click buttons on the screen, such as the calculator application you probably have installed on your system or phone.
We discuss more about data type conversions and bit operations in Chapter 10, “More on Variables and Data Types.”
In several of the exercises that follow, you’ll see that one additional benefit of defining a Calculator class has to do with the ease of extending it.

